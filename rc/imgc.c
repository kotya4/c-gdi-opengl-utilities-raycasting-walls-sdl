#include <stdio.h> // fopen, printf
#include <string.h> // strncat
#include <stdint.h> // uint8_t
#include <math.h> // log2
#include <time.h> // time
#include "imgfiles.h"
#include "bmp/bmp.h"
#include "vector.h"
#include "bmp/bmp_indexed.h"


int
main () {
  
  vectoru8_t colors = { NULL, 0, 0 }; // 8 bits per image ( rgb332 )
  vectorbit_t colorsnum = { NULL, 0, 0, 0 }; // 4 bits per image ( 16 colors max )
  vectorbit_t imagesizes = { NULL, 0, 0, 0 }; // 4 bits per image ( WxH : 32, 64, 128, 256 )
  vectorbit_t images = { NULL, 0, 0, 0 }; // various bits per image
  
  for ( int i = 0; i < IMG_files_length; ++i ) {

    char path[ 100 ] = "imgs/";
    strncat ( path, IMG_files[ i ], 100 );
    
    BMP_obj_t bmp;
    if ( BMP_read ( &bmp, path ) < 0 ) {
      printf ( "BMP_read: cannot find %s or smth\n", path );
      continue;
    }
    
    BMP_mirror ( &bmp );
    
    int status;
    BMP_indexed_t ibmp;
    status = BMP_indexed_init ( &ibmp, &bmp, -1 );
    if ( status < 0 ) {
      printf ( "BMP_indexed_init: returns status %d on file %s\n", status, path );
      continue;
    }

    uint8_t w, h;
    if ( ibmp.width == 32 ) w = 0b00;
    else if ( ibmp.width == 64 ) w = 0b01;
    else if ( ibmp.width == 128 ) w = 0b10;
    else if ( ibmp.width == 256 ) w = 0b11;
    else {
      printf ( "file %s has incompatible width %d\n", path, ibmp.width );
      continue;
    }
    if ( ibmp.height == 32 ) h = 0b00;
    else if ( ibmp.height == 64 ) h = 0b01;
    else if ( ibmp.height == 128 ) h = 0b10;
    else if ( ibmp.height == 256 ) h = 0b11;
    else {
      printf ( "file %s has incompatible height %d\n", path, ibmp.height );
      continue;
    }
    status = vectorbit_push_many ( &imagesizes, w, 2 );
    status = vectorbit_push_many ( &imagesizes, h, 2 );
    if ( status < 0 ) {
      printf ( "vectorbit_push_many: returns status" );
      printf ( " %d on file %s w %d h %d\n", status, path, w, h );
      continue;
    }

    if ( ibmp.palette.length > 16 || ibmp.palette.length < 1 ) {
      printf ( "palette size incompatible ( %d ) ", ibmp.palette.length );
      printf ( "on file %s\n", path );
      continue;
    }
    
    status = vectorbit_push_many ( &colorsnum, ibmp.palette.length - 1, 4 );
    if ( status < 0 ) {
      printf ( "vectorbit_push_many: returns status" );
      printf ( " %d on file %s palette length %d\n", status, path, ibmp.palette.length );
      continue;
    }

    for ( int k = 0; k < ibmp.palette.length; ++k ) {
      const uint8_t r = ibmp.palette.colors[ k ].r;
      const uint8_t g = ibmp.palette.colors[ k ].g;
      const uint8_t b = ibmp.palette.colors[ k ].b;
      #define CVT8TO3( v ) ( v / 32 + ( int ) ( v / 32.0 - v / 32 >= 0.5 ) )
      #define CVT8TO2( v ) ( v / 64 + ( int ) ( v / 64.0 - v / 64 >= 0.5 ) )
      const uint8_t rgb332
        = CVT8TO3 ( r ) << 5
        | CVT8TO3 ( g ) << 2
        | CVT8TO2 ( b ) << 0 ;
      status = vectoru8_push ( &colors, rgb332 );
      if ( status < 0 ) {
        printf ( "vectoru8_push: returns status" );
        printf ( " %d on file %s palette index %d\n", status, path, k );
        continue;
      }
    }
    
    const int indexcap = ( int ) ceil ( log2 ( ibmp.palette.length ) );
    
    for ( int k = 0; k < ibmp.length; ++k ) {
      status = vectorbit_push_many ( &images, ibmp.array[ k ], indexcap );
      if ( status < 0 ) {
        printf ( "vectorbit_push_many: returns status" );
        printf ( " %d on file %s array index %d\n", status, path, k );
        continue;
      }
    }
    
    BMP_indexed_kill ( &ibmp );
    
    BMP_kill ( &bmp );
  }
  
  // TODO: uint8s as string 
  #define FILEPATH "img.h"
  FILE *f = fopen ( FILEPATH, "w" );
  if ( !f ) {
    printf ( "fopen: cannot write file %s\n", FILEPATH );
  } else {
    fprintf ( f, "// This file was generated by imgc.c at POSIX TIME %d\n", time ( NULL ) );
    fprintf ( f, "#ifndef IMG_H\n" );
    fprintf ( f, "#define IMG_H\n" );
    fprintf ( f, "\n" );
    fprintf ( f, "#define IMG_COLORS_LENGTH %d\n", colors.length );
    fprintf ( f, "#define IMG_COLORSNUM_LENGTH %d\n", colorsnum.byteindex + 1 );
    fprintf ( f, "#define IMG_IMAGESIZES_LENGTH %d\n", imagesizes.byteindex + 1 );
    fprintf ( f, "#define IMG_IMAGES_LENGTH %d\n", images.byteindex + 1 );
    fprintf ( f, "#define IMG_FILES_LENGTH %d\n", IMG_files_length );
    // because of various image size we must store images bitslength
    fprintf ( f, "#define IMG_BITSLENGTH %d\n", images.bitslength ); 
    fprintf ( f, "\n" );
    fprintf ( f, "// After passing arrays to BMP_d they'll be corrupted\n" );
    fprintf ( f, "unsigned char IMG_colors[ IMG_COLORS_LENGTH ] = {" );
    for ( int i = 0; i < colors.length; ++i ) 
      fprintf ( f, "%d,", colors.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "unsigned char IMG_colorsnum[ IMG_COLORSNUM_LENGTH ] = {" );
    for ( int i = 0; i < colorsnum.byteindex + 1; ++i ) 
      fprintf ( f, "%d,", colorsnum.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "unsigned char IMG_imagesizes[ IMG_IMAGESIZES_LENGTH ] = {" );
    for ( int i = 0; i < imagesizes.byteindex + 1; ++i )
      fprintf ( f, "%d,", imagesizes.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "unsigned char IMG_images[ IMG_IMAGES_LENGTH ] = {" );
    for ( int i = 0; i < images.byteindex + 1; ++i ) 
      fprintf ( f, "%d,", images.array[ i ] );
    fprintf ( f, "};\n" );
    fprintf ( f, "\n" );
    fprintf ( f, "#endif // IMG_H\n" );
    fclose ( f );
  }
  
  free ( colors.array );
  free ( colorsnum.array );
  free ( imagesizes.array );
  free ( images.array );

}
